// This file is @generated by prost-build.
/// Originating from an AppFlowy Client.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientOrigin {
  /// User id.
  #[prost(int64, tag = "1")]
  pub uid: i64,
  /// Device id.
  #[prost(string, tag = "2")]
  pub device_id: ::prost::alloc::string::String,
}
/// Unknown origin.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmptyOrigin {}
/// Originating from the AppFlowy Server.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerOrigin {}
/// Origin of a collab message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollabOrigin {
  #[prost(oneof = "collab_origin::Origin", tags = "1, 2, 3")]
  pub origin: ::core::option::Option<collab_origin::Origin>,
}
/// Nested message and enum types in `CollabOrigin`.
pub mod collab_origin {
  #[allow(clippy::derive_partial_eq_without_eq)]
  #[derive(Clone, PartialEq, ::prost::Oneof)]
  pub enum Origin {
    #[prost(message, tag = "1")]
    Empty(super::EmptyOrigin),
    #[prost(message, tag = "2")]
    Client(super::ClientOrigin),
    #[prost(message, tag = "3")]
    Server(super::ServerOrigin),
  }
}
/// Collab Type.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CollabType {
  Unknown = 0,
  Document = 1,
  Database = 2,
  WorkspaceDatabase = 3,
  Folder = 4,
  DatabaseRow = 5,
  UserAwareness = 6,
}
impl CollabType {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      CollabType::Unknown => "COLLAB_TYPE_UNKNOWN",
      CollabType::Document => "COLLAB_TYPE_DOCUMENT",
      CollabType::Database => "COLLAB_TYPE_DATABASE",
      CollabType::WorkspaceDatabase => "COLLAB_TYPE_WORKSPACE_DATABASE",
      CollabType::Folder => "COLLAB_TYPE_FOLDER",
      CollabType::DatabaseRow => "COLLAB_TYPE_DATABASE_ROW",
      CollabType::UserAwareness => "COLLAB_TYPE_USER_AWARENESS",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "COLLAB_TYPE_UNKNOWN" => Some(Self::Unknown),
      "COLLAB_TYPE_DOCUMENT" => Some(Self::Document),
      "COLLAB_TYPE_DATABASE" => Some(Self::Database),
      "COLLAB_TYPE_WORKSPACE_DATABASE" => Some(Self::WorkspaceDatabase),
      "COLLAB_TYPE_FOLDER" => Some(Self::Folder),
      "COLLAB_TYPE_DATABASE_ROW" => Some(Self::DatabaseRow),
      "COLLAB_TYPE_USER_AWARENESS" => Some(Self::UserAwareness),
      _ => None,
    }
  }
}
/// Encoded collaborative document.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncodedCollab {
  /// yrs state vector
  #[prost(bytes = "vec", tag = "1")]
  pub state_vector: ::prost::alloc::vec::Vec<u8>,
  /// yrs document state
  #[prost(bytes = "vec", tag = "2")]
  pub doc_state: ::prost::alloc::vec::Vec<u8>,
  /// yrs encoder version used for the state vector and doc state
  #[prost(enumeration = "EncoderVersion", tag = "3")]
  pub encoder_version: i32,
}
/// yrs encoder version.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EncoderVersion {
  Unknown = 0,
  V1 = 1,
  V2 = 2,
}
impl EncoderVersion {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      EncoderVersion::Unknown => "ENCODER_VERSION_UNKNOWN",
      EncoderVersion::V1 => "ENCODER_VERSION_V1",
      EncoderVersion::V2 => "ENCODER_VERSION_V2",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "ENCODER_VERSION_UNKNOWN" => Some(Self::Unknown),
      "ENCODER_VERSION_V1" => Some(Self::V1),
      "ENCODER_VERSION_V2" => Some(Self::V2),
      _ => None,
    }
  }
}
/// Embeddings and the associated collab metadata.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollabEmbeddingsParams {
  /// Fragment id.
  #[prost(string, tag = "1")]
  pub fragment_id: ::prost::alloc::string::String,
  /// Collab object id.
  #[prost(string, tag = "2")]
  pub object_id: ::prost::alloc::string::String,
  /// Collab type.
  #[prost(enumeration = "CollabType", tag = "3")]
  pub collab_type: i32,
  /// Embedding content type.
  #[prost(enumeration = "EmbeddingContentType", tag = "4")]
  pub content_type: i32,
  /// Embedding content as string.
  #[prost(string, tag = "5")]
  pub content: ::prost::alloc::string::String,
  /// Embedding as float array.
  #[prost(float, repeated, tag = "6")]
  pub embedding: ::prost::alloc::vec::Vec<f32>,
}
/// Wrapper over a collection of embeddings, together with metadata associated on the collection level.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollabEmbeddings {
  /// OpenAPI tokens consumed.
  #[prost(uint32, tag = "1")]
  pub tokens_consumed: u32,
  /// List of embeddings.
  #[prost(message, repeated, tag = "2")]
  pub embeddings: ::prost::alloc::vec::Vec<CollabEmbeddingsParams>,
}
/// Payload for sending and receive collab over http.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollabParams {
  #[prost(string, tag = "1")]
  pub object_id: ::prost::alloc::string::String,
  /// Serialized EncodedCollab object, which could either be in bincode or protobuf serialization format.
  #[prost(bytes = "vec", tag = "2")]
  pub encoded_collab: ::prost::alloc::vec::Vec<u8>,
  /// Collab type.
  #[prost(enumeration = "CollabType", tag = "3")]
  pub collab_type: i32,
  /// Document embeddings.
  #[prost(message, optional, tag = "4")]
  pub embeddings: ::core::option::Option<CollabEmbeddings>,
}
/// Payload for creating batch of collab over http.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateCollabParams {
  /// Workspace id.
  #[prost(string, tag = "1")]
  pub workspace_id: ::prost::alloc::string::String,
  /// List of collab params.
  #[prost(message, repeated, tag = "2")]
  pub params_list: ::prost::alloc::vec::Vec<CollabParams>,
}
/// Payload for creating new collab or update existing collab over http.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCollabParams {
  /// Workspace id.
  #[prost(string, tag = "1")]
  pub workspace_id: ::prost::alloc::string::String,
  /// Object id.
  #[prost(string, tag = "2")]
  pub object_id: ::prost::alloc::string::String,
  /// Serialized EncodedCollab object, which could either be in bincode or protobuf serialization format.
  #[prost(bytes = "vec", tag = "3")]
  pub encoded_collab: ::prost::alloc::vec::Vec<u8>,
  /// Collab type.
  #[prost(enumeration = "CollabType", tag = "4")]
  pub collab_type: i32,
}
/// Types of embeddings content.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmbeddingContentType {
  /// Unknown content type.
  Unknown = 0,
  /// Plain text
  PlainText = 1,
}
impl EmbeddingContentType {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      EmbeddingContentType::Unknown => "EMBEDDING_CONTENT_TYPE_UNKNOWN",
      EmbeddingContentType::PlainText => "EMBEDDING_CONTENT_TYPE_PLAIN_TEXT",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "EMBEDDING_CONTENT_TYPE_UNKNOWN" => Some(Self::Unknown),
      "EMBEDDING_CONTENT_TYPE_PLAIN_TEXT" => Some(Self::PlainText),
      _ => None,
    }
  }
}
